import os
import json
import numpy


def evaluate_more_nearest_dis_triplets(path_name, search_num=1):
    """
        Validation of the modeling results of Chart2Vec, based on the vectors generated by the model. Specify a chart, compute the topk nearest charts to it, determine if it is located in a context window, and compute the context distance.
        Inputs:
            `path_name`: Chart vectors generated according to the Chart2Vec model.
            `search_num`: The number of charts to search for the nearest ones, which defaults to one, i.e., searching for the charts that are closest to the selected chart.
    """
    path = os.path.dirname(__file__)
    data_path = os.path.join(path, path_name)
    with open(data_path) as f:
        data = json.load(f)

    same_dataset_facts, accuracy_list_window2, accuracy_list_window3, accuracy_list_story = {}, {}, {}, {}
    last_dataset_key = ""
    for key in list(data.keys()):
        dataset_label = key.split("-", 1)[0]
        if len(same_dataset_facts) == 0 or (len(same_dataset_facts) > 0 and dataset_label == list(same_dataset_facts.keys())[0].split("-", 1)[0]):
            same_dataset_facts[key] = data[key]
            last_dataset_key = key.split("-", 1)[0]
        else:
            # 1. first calculate the accuracy between facts in the last dataset
            accuracy_list_window2[last_dataset_key],  accuracy_list_window3[last_dataset_key] , accuracy_list_story[last_dataset_key] = cal_same_dataset_facts_more_dis_min(
                same_dataset_facts, search_num)
            # 2. set to null, add a new
            same_dataset_facts = {}
            same_dataset_facts[key] = data[key]
    # 3. calculate the accuracy of the last dataset
    accuracy_list_window2[key], accuracy_list_window3[key], accuracy_list_story[key] = cal_same_dataset_facts_more_dis_min(
        same_dataset_facts, search_num)
    return cal_avg_accuracy_value(accuracy_list_window2),cal_avg_accuracy_value(accuracy_list_window3),cal_avg_accuracy_value(accuracy_list_story)

def cal_avg_accuracy_value(accuracy_list):
    """
        Each set of dashboards has an exact value and an overall average needs to be calculated
    """
    accuracy_list = dict(sorted(accuracy_list.items(), key=lambda d: d[1], reverse=True))
    return numpy.mean(list(accuracy_list.values()))

def cal_same_dataset_facts_more_dis_min(facts_dict, search_num):
    """
        Search for the nearest multiple and store.
    """
    dis_map = {}
    facts_dict_key = list(facts_dict.keys())
    for i in range(len(facts_dict)):
        temp_dis_map = {}
        key1 = facts_dict_key[i]
        fact1_id = key1.split("-", 1)[1]
        value1 = numpy.array(facts_dict[key1])
        for j in range(len(facts_dict)):
            if i == j:
                continue
            key2 = facts_dict_key[j]
            fact2_id = key2.split("-", 1)[1]
            value2 = numpy.array(facts_dict[key2])
            dis = eucliDist(value1, value2)
            if len(temp_dis_map.keys()) < search_num:
                temp_dis_map[fact2_id] = dis
            else:
                # if the value is already stored, find the largest one and replace it if it is smaller than it.
                temp_max_key = max(temp_dis_map, key=temp_dis_map.get)
                if dis < temp_dis_map[temp_max_key] and dis > 0:
                    del temp_dis_map[temp_max_key]
                    temp_dis_map[fact2_id] = dis

        dis_map[fact1_id] = temp_dis_map

    # calculate whether two by two is a context
    is_context, is_context_window2, is_context_window3, is_context_story = 0, 0, 0, 0
    for key in dis_map.keys():
        fact1_id = key
        for fact2 in dis_map[key].keys():
            fact2_id = fact2
            if fact1_id.split("-")[0] != fact2_id.split("-")[0]:
                continue
            if int(fact1_id.split("-")[1])+1 == int(fact2_id.split("-")[1]) or int(fact1_id.split("-")[1])-1 == int(fact2_id.split("-")[1]):
                is_context += 1
                is_context_window2 += 1
                is_context_window3 += 1
                is_context_story += 1
                break
            if int(fact1_id.split("-")[1])+2 == int(fact2_id.split("-")[1]) or int(fact1_id.split("-")[1])-2 == int(fact2_id.split("-")[1]):
                is_context_window2 += 1
                is_context_window3 += 1
                is_context_story += 1
                break
            if int(fact1_id.split("-")[1])+3 == int(fact2_id.split("-")[1]) or int(fact1_id.split("-")[1])-3 == int(fact2_id.split("-")[1]):
                is_context_window3 += 1
                is_context_story += 1
                break
            if int(fact1_id.split("-")[0]) == int(fact2_id.split("-")[0]):
                is_context_story += 1
                break

    window2_accuracy = float(is_context_window2/len(dis_map.keys()))
    window3_accuracy = float(is_context_window3/len(dis_map.keys()))
    story_accuracy = float(is_context_story/len(dis_map.keys()))
    return window2_accuracy, window3_accuracy, story_accuracy


def eucliDist(A, B):
    return numpy.sqrt(sum(numpy.power((A - B), 2)))


if __name__ == "__main__":
    path_name = "results/chart2vec_base_batch128_struct16_epoch20_lr0.005-result.json"
    top2_acc, top3_acc, cooc_acc = evaluate_more_nearest_dis_triplets(
        path_name, search_num=1)
    print("context window=2:", top2_acc)
    print("context window=3:", top3_acc)
    print("context in the same story:", cooc_acc)
